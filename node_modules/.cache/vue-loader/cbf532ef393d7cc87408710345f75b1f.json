{"remainingRequest":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/wuzhanfly/git/filscan-frontend/src/views/home/components/table/BlockTable.vue?vue&type=style&index=0&id=29ab4f85&lang=scss&scoped=true&","dependencies":[{"path":"/home/wuzhanfly/git/filscan-frontend/src/views/home/components/table/BlockTable.vue","mtime":1612684657988},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLmJsb2NrLW1pbmVyLXRhYmxlIHsKICBkaXNwbGF5OiBmbGV4OwogICYgPiBkaXYgewogICAgZmxleDogMTsKICAgIG1heC13aWR0aDogNTAlOwogICAgYmFja2dyb3VuZDogdmFyKC0tbWFpbi1iZy1jb2xvcik7CiAgfQogICYgPiBkaXY6Zmlyc3QtY2hpbGQgewogICAgbWFyZ2luLXJpZ2h0OiAxMHB4OwogIH0KICAudGFibGUtdGl0bGUgewogICAgcGFkZGluZzogMTVweDsKICAgIGJhY2tncm91bmQ6IHZhcigtLW1haW4tYmctY29sb3IpOwogICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNjY2M7CiAgICBkaXNwbGF5OiBmbGV4OwogICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOwogICAgaW1nIHsKICAgICAgd2lkdGg6IDIwcHg7CiAgICAgIG1hcmdpbi1yaWdodDogMTVweDsKICAgIH0KICB9Cn0K"},{"version":3,"sources":["BlockTable.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"BlockTable.vue","sourceRoot":"src/views/home/components/table","sourcesContent":["<template>\n  <div class=\"block-table\">\n    <base-table\n      :dataSource=\"blockTable.dataSource\"\n      :columns=\"blockTable.columns\"\n      :loadMore=\"true\"\n      @load=\"loadBlockData\"\n      :showLoading=\"blockTable.loading\"\n      :showAppend=\"blockTable.append && !isMobile\"\n      @click-append=\"goTo('tipset')\"\n      :span-map=\"blockTable.heightMap\"\n      :span=\"blockTable.span\"\n      :max-height=\"isMobile ? 200 : 400 * rate\"\n      :labels=\"$t('home.blockTable.label')\"\n      radius\n      :stripe=\"false\"\n    ></base-table>\n  </div>\n</template>\n<script>\nimport { getLatestBlock } from \"@/api/home\";\nimport { mapState } from \"vuex\";\nexport default {\n  name: \"BlockTable\",\n  data() {\n    return {\n      blockTable: {\n        dataSource: [],\n        span: true,\n        columns: [\n          {\n            key: \"height\",\n            isLink: true,\n            target: \"tipset\"\n          },\n          {\n            key: \"hash\",\n            isLink: true,\n            target: \"tipset\",\n            ellipsis: true\n          },\n          {\n            key: \"time\"\n          },\n          {\n            key: \"miner\",\n            isLink: true,\n            target: \"address/detail\",\n            paramKey: \"address\"\n          },\n          {\n            key: \"reward\",\n            unit: \"FIL\"\n          }\n        ],\n        loadCount: 0,\n        loading: false,\n        append: false,\n        heightMap: {},\n        timer: null\n      }\n    };\n  },\n  methods: {\n    initBlockTimer() {\n      this.blockTable.timer = setInterval(() => {\n        this.blockTable.heightMap = {};\n        const heightMap = {};\n        this.blockTable.dataSource = this.blockTable.dataSource.map(\n          (item, index) => {\n            if (heightMap[item.height]) {\n              heightMap[item.height].span++;\n            } else {\n              heightMap[item.height] = {\n                span: 1,\n                index: index\n              };\n            } //表头合并\n            return {\n              ...item,\n              time: this.formatTime(item.originTime, item.current),\n              current: item.current + 1000\n            };\n          }\n        );\n        Object.values(heightMap).forEach(item => {\n          this.blockTable.heightMap[item.index] = item.span;\n        });\n      }, 1000);\n    },\n    async getBlockData(num) {\n      if (num > 30) {\n        return;\n      }\n      this.blockTable.heightMap = {};\n      this.blockTable.loading = true;\n      this.blockTable.span = false;\n      try {\n        const data = await getLatestBlock(num);\n        const heightMap = {};\n        const dataSource = data.block_header.map((item, index) => {\n          const { height, miner, timestamp } = item.block_header;\n          if (heightMap[height]) {\n            heightMap[height].span++;\n          } else {\n            heightMap[height] = {\n              span: 1,\n              index\n            };\n          } //表头合并\n          const current = new Date().getTime();\n          const realTime =\n            timestamp > current / 1000 ? current / 1000 : timestamp;\n          return {\n            height: this.formatNumber(height),\n            hash: item.cid,\n            time: this.formatTime(realTime),\n            originTime: realTime,\n            miner: miner,\n            reward: Number(item.reward).toFixed(5),\n            current: current\n          };\n        });\n        this.blockTable.dataSource = dataSource;\n        Object.values(heightMap).forEach(item => {\n          this.blockTable.heightMap[item.index] = item.span;\n        });\n        this.blockTable.loading = false;\n        this.blockTable.span = true;\n        return Promise.resolve();\n      } catch (e) {\n        this.blockTable.loading = false;\n      }\n    },\n    async loadBlockData() {\n      if (this.blockTable.loading) {\n        return;\n      }\n      if (this.blockTable.loadCount == 3) {\n        this.blockTable.append = true;\n        return;\n      } else {\n        clearInterval(this.blockTable.timer);\n        try {\n          this.blockTable.loading = true;\n          await this.getBlockData(10 * (this.blockTable.loadCount + 1));\n          this.blockTable.loadCount++;\n          this.blockTable.loading = false;\n          this.initBlockTimer();\n        } catch (e) {\n          this.blockTable.loading = false;\n        }\n      }\n    }\n  },\n  watch: {\n    async latestBlockHeight() {\n      if (this.loadCount === 1) {\n        return;\n      }\n      clearInterval(this.blockTable.timer);\n      await this.getBlockData(this.blockTable.loadCount * 10);\n      this.initBlockTimer();\n    }\n  },\n  beforeDestroy() {\n    clearInterval(this.blockTable.timer);\n  },\n  computed: {\n    ...mapState([\"rate\"])\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n.block-miner-table {\n  display: flex;\n  & > div {\n    flex: 1;\n    max-width: 50%;\n    background: var(--main-bg-color);\n  }\n  & > div:first-child {\n    margin-right: 10px;\n  }\n  .table-title {\n    padding: 15px;\n    background: var(--main-bg-color);\n    border-bottom: 1px solid #ccc;\n    display: flex;\n    justify-content: space-between;\n    img {\n      width: 20px;\n      margin-right: 15px;\n    }\n  }\n}\n</style>\n"]}]}