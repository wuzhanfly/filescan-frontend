{"remainingRequest":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/wuzhanfly/git/filscan-frontend/src/views/tipset/components/TicketChain.vue?vue&type=style&index=0&id=32871e0c&lang=scss&scoped=true&","dependencies":[{"path":"/home/wuzhanfly/git/filscan-frontend/src/views/tipset/components/TicketChain.vue","mtime":1612684657988},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoudGlja2V0LWNoYWluIHsKICBib3JkZXItcmFkaXVzOiA4cHg7CiAgYm94LXNoYWRvdzogMHB4IDFweCA3cHggOXB4IHJnYmEoMCwgMCwgMCwgMC4wMyk7CiAgYmFja2dyb3VuZDogdmFyKC0tYm9hcmQtYmctY29sb3IpOwogIC5jaGFydC1jb24gewogICAgd2lkdGg6IDEwMCU7CiAgICAuY2hhcnQgewogICAgICB3aWR0aDogMTAwJTsKICAgICAgaGVpZ2h0OiAzNTBweDsKICAgIH0KICB9CiAgLmJsb2NrLXR5cGUgewogICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgei1pbmRleDogMTA7CiAgICAuYXJyb3cgewogICAgICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgICAgIHRvcDogLTEwcHg7CiAgICAgIGZvbnQtc2l6ZTogMzBweDsKICAgICAgY29sb3I6IHZhcigtLW1haW4tdGV4dC1jb2xvcik7CiAgICAgIGN1cnNvcjogcG9pbnRlcjsKICAgICAgJi5sZWZ0IHsKICAgICAgICBsZWZ0OiAyMHB4OwogICAgICB9CiAgICAgICYucmlnaHQgewogICAgICAgIHJpZ2h0OiAyMHB4OwogICAgICB9CiAgICB9CiAgfQogIC5ibG9jay10eXBlIGRpdi50eXBlLWxpc3QgewogICAgd2lkdGg6IDUwMHB4OwogICAgbWFyZ2luOiAwIGF1dG87CiAgICBwYWRkaW5nLWJvdHRvbTogMjBweDsKICAgIGNvbG9yOiB2YXIoLS1tYWluLXRleHQtY29sb3IpOwogICAgc3BhbiB7CiAgICAgIG1hcmdpbi1sZWZ0OiAyMHB4OwogICAgfQogICAgaSB7CiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jazsKICAgICAgd2lkdGg6IDEwcHg7CiAgICAgIGhlaWdodDogMTBweDsKICAgICAgYm9yZGVyLXJhZGl1czogNTAlOwogICAgICBtYXJnaW4tcmlnaHQ6IDVweDsKICAgICAgJi5udWxsIHsKICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1udWxsLWJsb2NrLWJnLWNvbG9yKTsKICAgICAgfQogICAgICAmLnRpY2tldCB7CiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tdGlja2V0LWJsb2NrLWJnLWNvbG9yKTsKICAgICAgfQogICAgICAmLm5vcm1hbCB7CiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tb3RoZXItYmxvY2stYm9yZGVyLWNvbG9yKTsKICAgICAgICB3aWR0aDogOHB4OwogICAgICAgIGhlaWdodDogOHB4OwogICAgICB9CiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["TicketChain.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"TicketChain.vue","sourceRoot":"src/views/tipset/components","sourcesContent":["<template>\n  <div class=\"ticket-chain\">\n    <div class=\"chart-con\">\n      <div\n        class=\"chart\"\n        ref=\"chart\"\n        v-loading=\"loading\"\n        element-loading-background=\"var(--board-bg-color)\"\n      ></div>\n      <div class=\"block-type\" :style=\"typeStyle\">\n        <div class=\"arrow left\" @click=\"goLeft\" v-if=\"!atIndex\">\n          <span class=\"el-icon-arrow-left\"></span>\n        </div>\n        <div class=\"type-list\">\n          <span>\n            <i class=\"null\"></i>\n            {{ $t(\"tipset.blockType\")[0] }}\n          </span>\n          <span>\n            <i class=\"ticket\"></i>\n            {{ $t(\"tipset.blockType\")[1] }}\n          </span>\n          <span>\n            <i class=\"normal\"></i>\n            {{ $t(\"tipset.blockType\")[2] }}\n          </span>\n        </div>\n        <div @click=\"goRight\" class=\"arrow right\" v-if=\"!atIndex\">\n          <!-- <img src=\"@/assets/image/icons/right.png\" alt /> -->\n          <span class=\"el-icon-arrow-right\"></span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nimport { getBlockByCid, getTipset } from \"@/api/tipset\";\nimport { getLatestBlock } from \"@/api/home\";\nimport { getBlockCoord } from \"../tool\";\nimport { mapState } from \"vuex\";\nimport Null from \"@/assets/image/block/null.png\";\nimport Ticket from \"@/assets/image/block/ticket.png\";\nimport Normal from \"@/assets/image/block/normal.png\";\nimport Active from \"@/assets/image/block/active.png\";\nimport NormalDark from \"@/assets/image/block/normal-dark.png\";\nimport NullDark from \"@/assets/image/block/null-dark.png\";\nlet chart;\nexport default {\n  name: \"TipsetChain\",\n  data() {\n    return {\n      tipsets: [],\n      startHeight: 0,\n      hashList: [],\n      loading: false,\n      typeStyle: {\n        marginTop: \"-160px\"\n      },\n      jumpSafeHeight: 0\n    };\n  },\n  props: {\n    hash: {\n      type: String,\n      default: \"\"\n    },\n    height: {\n      type: Number,\n      default: 0\n    }\n  },\n  computed: {\n    ...mapState([\"defaultHeight\"]),\n    normalSrc() {\n      return this.theme === \"light\" ? Normal : NormalDark;\n    },\n    ticketSrc() {\n      return this.theme === \"light\" ? Ticket : Active;\n    },\n    activeSrc() {\n      return this.theme === \"light\" ? Active : Ticket;\n    },\n    nullSrc() {\n      return this.theme === \"light\" ? Null : NullDark;\n    }\n  },\n  watch: {\n    height(v) {\n      if ((v <= this.startHeight && v > this.startHeight - 15) || v == 0) {\n        this.drawChart();\n      } else {\n        this.getTipset(v);\n      }\n    },\n    async hash(v) {\n      if (!v) {\n        return;\n      }\n      if (this.hashList.includes(v)) {\n        this.drawChart();\n      } else {\n        //for parent hash click\n        let data = await getBlockByCid({\n          cid: this.$route.query.hash\n        });\n        const height = data.blocks[0].block_header.height;\n        this.getTipset(height);\n      }\n    },\n    defaultHeight: {\n      handler(h) {\n        const { height, hash, jumpHeight } = this.$route.query;\n        if ((height || hash || jumpHeight) && !this.atIndex) {\n          return;\n        }\n        if (h != 0) {\n          this.startHeight = h;\n          this.getTipset(h);\n        }\n      }\n    },\n    theme() {\n      this.drawChart();\n    }\n  },\n  async mounted() {\n    chart = this.$chart.init(this.$refs.chart);\n    const height = this.height;\n    let currentHeight;\n    if (height) {\n      currentHeight = height;\n    } else if (this.hash) {\n      let data = await getBlockByCid({\n        cid: this.$route.query.hash\n      });\n      const height = data.blocks[0].block_header.height;\n      currentHeight = height;\n    } else {\n      let data = await getLatestBlock(1);\n      const height = data.block_header[0].block_header.height;\n      currentHeight = height;\n      this.jumpSafeHeight = height;\n    }\n    this.getTipset(currentHeight);\n    chart.on(\"click\", e => {\n      if (e.data.originData) {\n        this.$emit(\"hash-change\", e.data.originData.cid);\n      }\n      if (e.componentType === \"markLine\") {\n        this.$emit(\"height-change\", String(this.startHeight - e.value));\n      }\n    });\n  },\n  methods: {\n    async getTipset(height) {\n      if (height == 0) {\n        return;\n      }\n      if (height < 15) {\n        height = 15;\n      }\n      try {\n        this.loading = true;\n        const res = await getTipset({\n          end_height: height,\n          count: 15\n        });\n        this.loading = false;\n        let blocks = [];\n        const reverse = res.tipsets.reverse();\n        reverse.forEach(item => {\n          if (item.tipset.length > 0) {\n            blocks = blocks.concat(item.tipset);\n          }\n        });\n        blocks = blocks.map(item => {\n          const { size, cid, reward, block_header, msg_cids } = item;\n          const {\n            timestamp,\n            height,\n            miner,\n            parent_weight,\n            tickets,\n            parents,\n            parent_state_root\n          } = block_header;\n\n          return {\n            height: this.formatNumber(height),\n            hash: cid,\n            timestamp: this.formatTime(timestamp),\n            utcTime: this.getFormatTime(timestamp),\n            size: this.formatNumber(size),\n            mesLength: msg_cids.length,\n            miner,\n            reward,\n            parents,\n            parent_weight: this.formatNumber(parent_weight),\n            tickets,\n            state_root: parent_state_root\n          };\n        });\n        const hashList = blocks.map(item => {\n          return item.hash;\n        });\n        this.hashList = hashList;\n        this.startHeight = height;\n        this.tipsets = Object.freeze(reverse);\n        this.$emit(\"get-blocks\", blocks);\n        this.drawChart();\n      } catch (e) {\n        this.loading = false;\n      }\n    },\n    drawChart() {\n      const height = this.height;\n      const rate = this.rate;\n      const {\n        ticketNode,\n        otherNode,\n        link,\n        seriesMarkLine,\n        seriesMarkLineLabel,\n        markArea,\n        markAreaBorder,\n        markAreaActiveBorder\n      } = this.chartTheme.tipset;\n      this.tipsets.forEach((item, index) => {\n        item.tipset = getBlockCoord(item.tipset, index, item.min_ticket_block);\n      }); //get coords\n      const nodeList = this.tipsets.reduce((pre, cur) => {\n        const coords = cur.tipset.map((item, index) => {\n          if (!item.cid) {\n            return {\n              value: item.coord,\n              symbol: `image://${this.nullSrc}`,\n              symbolSize: [56 * rate, 17 * rate],\n              isTicket: false,\n              label: {\n                show: false\n              }\n            };\n          }\n          const formatName = item.block_header.miner;\n          let symbol;\n          if (item.cid === this.hash) {\n            symbol = `image://${this.activeSrc}`;\n          } else if (index === 0) {\n            symbol = `image://${this.ticketSrc}`;\n          } else {\n            symbol = `image://${this.normalSrc}`;\n          }\n          return {\n            name: item.cid,\n            originData: item,\n            value: item.coord,\n            symbol: symbol,\n            symbolSize: [56 * rate, 17 * rate],\n            symbolOffset: [10 * rate, 0],\n            isTicket: index === 0,\n            label: {\n              color:\n                index === 0 || item.cid === this.hash ? ticketNode : otherNode,\n              formatter() {\n                return formatName;\n              },\n              fontSize: 12 * rate\n            }\n          };\n        });\n        return pre.concat(coords);\n      }, []); //generate echarts nodes\n      const linkList = nodeList\n        .map((item, index) => {\n          if (!item.isTicket) {\n            return null;\n          }\n          return index;\n        })\n        .filter(item => {\n          return item !== null;\n        })\n        .map((item, index, arr) => {\n          return {\n            source: item,\n            target: arr[index + 1],\n            index: index,\n            height: nodeList[item].originData.block_header.height,\n            isNull: nodeList[item].isNull,\n            blockCount: nodeList[item].originData.blockCount,\n            x: nodeList[item].originData.coord[0],\n            label: {\n              normal: {\n                show: false\n              }\n            },\n            lineStyle: {\n              normal: {\n                color: link\n              }\n            }\n          };\n        }); //lines\n      const startHeight = this.startHeight;\n\n      //Change the height of a graph according to the number of blocks\n      const maxCount = linkList\n        .map(item => {\n          return item.blockCount;\n        })\n        .sort((a, b) => a - b)\n        .reverse()[0];\n      this.typeStyle = {\n        marginTop: `${maxCount * 20 - 200}px`\n      };\n      let lineList = [];\n      const format = this.formatNumber;\n      for (let i = 0; i < 15; i++) {\n        lineList.push({\n          xAxis: i,\n          label: {\n            show: true,\n            formatter() {\n              return format(startHeight - i);\n            }\n          }\n        });\n      }\n      let areaData = [];\n      linkList.forEach(item => {\n        let borderColor = markAreaBorder,\n          borderWidth = 1;\n        if (height && startHeight - height == item.x) {\n          borderColor = markAreaActiveBorder;\n          borderWidth = 2;\n        }\n        areaData.push([\n          {\n            coord: [item.x - 0.2, (item.blockCount + 1) * 5],\n            itemStyle: {\n              borderColor,\n              borderWidth\n            }\n          },\n          { coord: [item.x + 0.376, 1] }\n        ]);\n      });\n      var option = {\n        xAxis: {\n          show: false,\n          boundaryGap: false,\n          min: -1,\n          max: 15,\n          axisLine: {\n            show: false\n          },\n          axisTick: {\n            show: true,\n            alignWithLabel: true\n          },\n          splitLine: {\n            show: false\n          }\n        },\n        yAxis: {\n          min: 0,\n          max: 70,\n          show: false,\n          type: \"value\",\n          inverse: true\n        },\n        grid: {\n          top: 40 * rate,\n          left: -40,\n          right: 0,\n          bottom: 0\n        },\n        series: [\n          {\n            type: \"graph\",\n            layout: \"none\",\n            id: \"a\",\n            coordinateSystem: \"cartesian2d\",\n            edgeSymbol: [\"\", \"arrow\"],\n            label: {\n              show: true,\n              position: \"inside\"\n            },\n            lineStyle: {\n              normal: {\n                width: 2,\n                shadowColor: \"none\"\n              }\n            },\n            markLine: {\n              symbol: [\"none\", \"none\"],\n              silent: false,\n              lineStyle: {\n                color: seriesMarkLine,\n                width: 1,\n                type: \"solid\"\n              },\n              data: lineList,\n              label: {\n                position: \"start\",\n                color: seriesMarkLineLabel,\n                fontSize: 12 * rate\n              }\n            },\n            markArea: {\n              data: areaData,\n              itemStyle: {\n                color: markArea,\n                borderColor: markAreaBorder,\n                borderWidth: 1,\n                borderType: \"dotted\"\n              }\n            },\n            data: nodeList,\n            links: linkList,\n            z: 0,\n            zlevel: 4\n          }\n        ]\n      };\n      chart.setOption(option);\n    },\n    async goRight() {\n      let jumpHeight = Math.max(this.startHeight - 15, 15);\n      await this.getTipset(jumpHeight);\n      this.goTo(\"tipset\", {\n        query: {\n          jumpHeight\n        }\n      });\n    },\n    async goLeft() {\n      let jumpHeight = 0;\n      if (this.startHeight === this.jumpSafeHeight) {\n        return;\n      }\n      if (this.jumpSafeHeight === 0) {\n        let data = await getLatestBlock(1);\n        this.jumpSafeHeight = Number(data.block_header[0].block_header.height);\n      }\n      if (Number(this.startHeight) + 15 >= this.jumpSafeHeight) {\n        jumpHeight = this.jumpSafeHeight;\n      } else {\n        jumpHeight = Number(this.startHeight) + 15;\n      }\n      await this.getTipset(jumpHeight);\n      this.goTo(\"tipset\", {\n        query: {\n          jumpHeight: jumpHeight\n        }\n      });\n    }\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n.ticket-chain {\n  border-radius: 8px;\n  box-shadow: 0px 1px 7px 9px rgba(0, 0, 0, 0.03);\n  background: var(--board-bg-color);\n  .chart-con {\n    width: 100%;\n    .chart {\n      width: 100%;\n      height: 350px;\n    }\n  }\n  .block-type {\n    position: relative;\n    z-index: 10;\n    .arrow {\n      position: absolute;\n      top: -10px;\n      font-size: 30px;\n      color: var(--main-text-color);\n      cursor: pointer;\n      &.left {\n        left: 20px;\n      }\n      &.right {\n        right: 20px;\n      }\n    }\n  }\n  .block-type div.type-list {\n    width: 500px;\n    margin: 0 auto;\n    padding-bottom: 20px;\n    color: var(--main-text-color);\n    span {\n      margin-left: 20px;\n    }\n    i {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      border-radius: 50%;\n      margin-right: 5px;\n      &.null {\n        background: var(--null-block-bg-color);\n      }\n      &.ticket {\n        background: var(--ticket-block-bg-color);\n      }\n      &.normal {\n        border: 1px solid var(--other-block-border-color);\n        width: 8px;\n        height: 8px;\n      }\n    }\n  }\n}\n</style>\n"]}]}