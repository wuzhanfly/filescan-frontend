{"remainingRequest":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/wuzhanfly/git/filscan-frontend/src/views/tipset/components/TicketChain.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/wuzhanfly/git/filscan-frontend/src/views/tipset/components/TicketChain.vue","mtime":1612684657988},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7IGdldEJsb2NrQnlDaWQsIGdldFRpcHNldCB9IGZyb20gIkAvYXBpL3RpcHNldCI7CmltcG9ydCB7IGdldExhdGVzdEJsb2NrIH0gZnJvbSAiQC9hcGkvaG9tZSI7CmltcG9ydCB7IGdldEJsb2NrQ29vcmQgfSBmcm9tICIuLi90b29sIjsKaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICJ2dWV4IjsKaW1wb3J0IE51bGwgZnJvbSAiQC9hc3NldHMvaW1hZ2UvYmxvY2svbnVsbC5wbmciOwppbXBvcnQgVGlja2V0IGZyb20gIkAvYXNzZXRzL2ltYWdlL2Jsb2NrL3RpY2tldC5wbmciOwppbXBvcnQgTm9ybWFsIGZyb20gIkAvYXNzZXRzL2ltYWdlL2Jsb2NrL25vcm1hbC5wbmciOwppbXBvcnQgQWN0aXZlIGZyb20gIkAvYXNzZXRzL2ltYWdlL2Jsb2NrL2FjdGl2ZS5wbmciOwppbXBvcnQgTm9ybWFsRGFyayBmcm9tICJAL2Fzc2V0cy9pbWFnZS9ibG9jay9ub3JtYWwtZGFyay5wbmciOwppbXBvcnQgTnVsbERhcmsgZnJvbSAiQC9hc3NldHMvaW1hZ2UvYmxvY2svbnVsbC1kYXJrLnBuZyI7CmxldCBjaGFydDsKZXhwb3J0IGRlZmF1bHQgewogIG5hbWU6ICJUaXBzZXRDaGFpbiIsCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIHRpcHNldHM6IFtdLAogICAgICBzdGFydEhlaWdodDogMCwKICAgICAgaGFzaExpc3Q6IFtdLAogICAgICBsb2FkaW5nOiBmYWxzZSwKICAgICAgdHlwZVN0eWxlOiB7CiAgICAgICAgbWFyZ2luVG9wOiAiLTE2MHB4IgogICAgICB9LAogICAgICBqdW1wU2FmZUhlaWdodDogMAogICAgfTsKICB9LAogIHByb3BzOiB7CiAgICBoYXNoOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogIiIKICAgIH0sCiAgICBoZWlnaHQ6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAwCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgLi4ubWFwU3RhdGUoWyJkZWZhdWx0SGVpZ2h0Il0pLAogICAgbm9ybWFsU3JjKCkgewogICAgICByZXR1cm4gdGhpcy50aGVtZSA9PT0gImxpZ2h0IiA/IE5vcm1hbCA6IE5vcm1hbERhcms7CiAgICB9LAogICAgdGlja2V0U3JjKCkgewogICAgICByZXR1cm4gdGhpcy50aGVtZSA9PT0gImxpZ2h0IiA/IFRpY2tldCA6IEFjdGl2ZTsKICAgIH0sCiAgICBhY3RpdmVTcmMoKSB7CiAgICAgIHJldHVybiB0aGlzLnRoZW1lID09PSAibGlnaHQiID8gQWN0aXZlIDogVGlja2V0OwogICAgfSwKICAgIG51bGxTcmMoKSB7CiAgICAgIHJldHVybiB0aGlzLnRoZW1lID09PSAibGlnaHQiID8gTnVsbCA6IE51bGxEYXJrOwogICAgfQogIH0sCiAgd2F0Y2g6IHsKICAgIGhlaWdodCh2KSB7CiAgICAgIGlmICgodiA8PSB0aGlzLnN0YXJ0SGVpZ2h0ICYmIHYgPiB0aGlzLnN0YXJ0SGVpZ2h0IC0gMTUpIHx8IHYgPT0gMCkgewogICAgICAgIHRoaXMuZHJhd0NoYXJ0KCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5nZXRUaXBzZXQodik7CiAgICAgIH0KICAgIH0sCiAgICBhc3luYyBoYXNoKHYpIHsKICAgICAgaWYgKCF2KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGlmICh0aGlzLmhhc2hMaXN0LmluY2x1ZGVzKHYpKSB7CiAgICAgICAgdGhpcy5kcmF3Q2hhcnQoKTsKICAgICAgfSBlbHNlIHsKICAgICAgICAvL2ZvciBwYXJlbnQgaGFzaCBjbGljawogICAgICAgIGxldCBkYXRhID0gYXdhaXQgZ2V0QmxvY2tCeUNpZCh7CiAgICAgICAgICBjaWQ6IHRoaXMuJHJvdXRlLnF1ZXJ5Lmhhc2gKICAgICAgICB9KTsKICAgICAgICBjb25zdCBoZWlnaHQgPSBkYXRhLmJsb2Nrc1swXS5ibG9ja19oZWFkZXIuaGVpZ2h0OwogICAgICAgIHRoaXMuZ2V0VGlwc2V0KGhlaWdodCk7CiAgICAgIH0KICAgIH0sCiAgICBkZWZhdWx0SGVpZ2h0OiB7CiAgICAgIGhhbmRsZXIoaCkgewogICAgICAgIGNvbnN0IHsgaGVpZ2h0LCBoYXNoLCBqdW1wSGVpZ2h0IH0gPSB0aGlzLiRyb3V0ZS5xdWVyeTsKICAgICAgICBpZiAoKGhlaWdodCB8fCBoYXNoIHx8IGp1bXBIZWlnaHQpICYmICF0aGlzLmF0SW5kZXgpIHsKICAgICAgICAgIHJldHVybjsKICAgICAgICB9CiAgICAgICAgaWYgKGggIT0gMCkgewogICAgICAgICAgdGhpcy5zdGFydEhlaWdodCA9IGg7CiAgICAgICAgICB0aGlzLmdldFRpcHNldChoKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICB0aGVtZSgpIHsKICAgICAgdGhpcy5kcmF3Q2hhcnQoKTsKICAgIH0KICB9LAogIGFzeW5jIG1vdW50ZWQoKSB7CiAgICBjaGFydCA9IHRoaXMuJGNoYXJ0LmluaXQodGhpcy4kcmVmcy5jaGFydCk7CiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodDsKICAgIGxldCBjdXJyZW50SGVpZ2h0OwogICAgaWYgKGhlaWdodCkgewogICAgICBjdXJyZW50SGVpZ2h0ID0gaGVpZ2h0OwogICAgfSBlbHNlIGlmICh0aGlzLmhhc2gpIHsKICAgICAgbGV0IGRhdGEgPSBhd2FpdCBnZXRCbG9ja0J5Q2lkKHsKICAgICAgICBjaWQ6IHRoaXMuJHJvdXRlLnF1ZXJ5Lmhhc2gKICAgICAgfSk7CiAgICAgIGNvbnN0IGhlaWdodCA9IGRhdGEuYmxvY2tzWzBdLmJsb2NrX2hlYWRlci5oZWlnaHQ7CiAgICAgIGN1cnJlbnRIZWlnaHQgPSBoZWlnaHQ7CiAgICB9IGVsc2UgewogICAgICBsZXQgZGF0YSA9IGF3YWl0IGdldExhdGVzdEJsb2NrKDEpOwogICAgICBjb25zdCBoZWlnaHQgPSBkYXRhLmJsb2NrX2hlYWRlclswXS5ibG9ja19oZWFkZXIuaGVpZ2h0OwogICAgICBjdXJyZW50SGVpZ2h0ID0gaGVpZ2h0OwogICAgICB0aGlzLmp1bXBTYWZlSGVpZ2h0ID0gaGVpZ2h0OwogICAgfQogICAgdGhpcy5nZXRUaXBzZXQoY3VycmVudEhlaWdodCk7CiAgICBjaGFydC5vbigiY2xpY2siLCBlID0+IHsKICAgICAgaWYgKGUuZGF0YS5vcmlnaW5EYXRhKSB7CiAgICAgICAgdGhpcy4kZW1pdCgiaGFzaC1jaGFuZ2UiLCBlLmRhdGEub3JpZ2luRGF0YS5jaWQpOwogICAgICB9CiAgICAgIGlmIChlLmNvbXBvbmVudFR5cGUgPT09ICJtYXJrTGluZSIpIHsKICAgICAgICB0aGlzLiRlbWl0KCJoZWlnaHQtY2hhbmdlIiwgU3RyaW5nKHRoaXMuc3RhcnRIZWlnaHQgLSBlLnZhbHVlKSk7CiAgICAgIH0KICAgIH0pOwogIH0sCiAgbWV0aG9kczogewogICAgYXN5bmMgZ2V0VGlwc2V0KGhlaWdodCkgewogICAgICBpZiAoaGVpZ2h0ID09IDApIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKGhlaWdodCA8IDE1KSB7CiAgICAgICAgaGVpZ2h0ID0gMTU7CiAgICAgIH0KICAgICAgdHJ5IHsKICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlOwogICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGdldFRpcHNldCh7CiAgICAgICAgICBlbmRfaGVpZ2h0OiBoZWlnaHQsCiAgICAgICAgICBjb3VudDogMTUKICAgICAgICB9KTsKICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTsKICAgICAgICBsZXQgYmxvY2tzID0gW107CiAgICAgICAgY29uc3QgcmV2ZXJzZSA9IHJlcy50aXBzZXRzLnJldmVyc2UoKTsKICAgICAgICByZXZlcnNlLmZvckVhY2goaXRlbSA9PiB7CiAgICAgICAgICBpZiAoaXRlbS50aXBzZXQubGVuZ3RoID4gMCkgewogICAgICAgICAgICBibG9ja3MgPSBibG9ja3MuY29uY2F0KGl0ZW0udGlwc2V0KTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBibG9ja3MgPSBibG9ja3MubWFwKGl0ZW0gPT4gewogICAgICAgICAgY29uc3QgeyBzaXplLCBjaWQsIHJld2FyZCwgYmxvY2tfaGVhZGVyLCBtc2dfY2lkcyB9ID0gaXRlbTsKICAgICAgICAgIGNvbnN0IHsKICAgICAgICAgICAgdGltZXN0YW1wLAogICAgICAgICAgICBoZWlnaHQsCiAgICAgICAgICAgIG1pbmVyLAogICAgICAgICAgICBwYXJlbnRfd2VpZ2h0LAogICAgICAgICAgICB0aWNrZXRzLAogICAgICAgICAgICBwYXJlbnRzLAogICAgICAgICAgICBwYXJlbnRfc3RhdGVfcm9vdAogICAgICAgICAgfSA9IGJsb2NrX2hlYWRlcjsKCiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBoZWlnaHQ6IHRoaXMuZm9ybWF0TnVtYmVyKGhlaWdodCksCiAgICAgICAgICAgIGhhc2g6IGNpZCwKICAgICAgICAgICAgdGltZXN0YW1wOiB0aGlzLmZvcm1hdFRpbWUodGltZXN0YW1wKSwKICAgICAgICAgICAgdXRjVGltZTogdGhpcy5nZXRGb3JtYXRUaW1lKHRpbWVzdGFtcCksCiAgICAgICAgICAgIHNpemU6IHRoaXMuZm9ybWF0TnVtYmVyKHNpemUpLAogICAgICAgICAgICBtZXNMZW5ndGg6IG1zZ19jaWRzLmxlbmd0aCwKICAgICAgICAgICAgbWluZXIsCiAgICAgICAgICAgIHJld2FyZCwKICAgICAgICAgICAgcGFyZW50cywKICAgICAgICAgICAgcGFyZW50X3dlaWdodDogdGhpcy5mb3JtYXROdW1iZXIocGFyZW50X3dlaWdodCksCiAgICAgICAgICAgIHRpY2tldHMsCiAgICAgICAgICAgIHN0YXRlX3Jvb3Q6IHBhcmVudF9zdGF0ZV9yb290CiAgICAgICAgICB9OwogICAgICAgIH0pOwogICAgICAgIGNvbnN0IGhhc2hMaXN0ID0gYmxvY2tzLm1hcChpdGVtID0+IHsKICAgICAgICAgIHJldHVybiBpdGVtLmhhc2g7CiAgICAgICAgfSk7CiAgICAgICAgdGhpcy5oYXNoTGlzdCA9IGhhc2hMaXN0OwogICAgICAgIHRoaXMuc3RhcnRIZWlnaHQgPSBoZWlnaHQ7CiAgICAgICAgdGhpcy50aXBzZXRzID0gT2JqZWN0LmZyZWV6ZShyZXZlcnNlKTsKICAgICAgICB0aGlzLiRlbWl0KCJnZXQtYmxvY2tzIiwgYmxvY2tzKTsKICAgICAgICB0aGlzLmRyYXdDaGFydCgpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7CiAgICAgIH0KICAgIH0sCiAgICBkcmF3Q2hhcnQoKSB7CiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0OwogICAgICBjb25zdCByYXRlID0gdGhpcy5yYXRlOwogICAgICBjb25zdCB7CiAgICAgICAgdGlja2V0Tm9kZSwKICAgICAgICBvdGhlck5vZGUsCiAgICAgICAgbGluaywKICAgICAgICBzZXJpZXNNYXJrTGluZSwKICAgICAgICBzZXJpZXNNYXJrTGluZUxhYmVsLAogICAgICAgIG1hcmtBcmVhLAogICAgICAgIG1hcmtBcmVhQm9yZGVyLAogICAgICAgIG1hcmtBcmVhQWN0aXZlQm9yZGVyCiAgICAgIH0gPSB0aGlzLmNoYXJ0VGhlbWUudGlwc2V0OwogICAgICB0aGlzLnRpcHNldHMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHsKICAgICAgICBpdGVtLnRpcHNldCA9IGdldEJsb2NrQ29vcmQoaXRlbS50aXBzZXQsIGluZGV4LCBpdGVtLm1pbl90aWNrZXRfYmxvY2spOwogICAgICB9KTsgLy9nZXQgY29vcmRzCiAgICAgIGNvbnN0IG5vZGVMaXN0ID0gdGhpcy50aXBzZXRzLnJlZHVjZSgocHJlLCBjdXIpID0+IHsKICAgICAgICBjb25zdCBjb29yZHMgPSBjdXIudGlwc2V0Lm1hcCgoaXRlbSwgaW5kZXgpID0+IHsKICAgICAgICAgIGlmICghaXRlbS5jaWQpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICB2YWx1ZTogaXRlbS5jb29yZCwKICAgICAgICAgICAgICBzeW1ib2w6IGBpbWFnZTovLyR7dGhpcy5udWxsU3JjfWAsCiAgICAgICAgICAgICAgc3ltYm9sU2l6ZTogWzU2ICogcmF0ZSwgMTcgKiByYXRlXSwKICAgICAgICAgICAgICBpc1RpY2tldDogZmFsc2UsCiAgICAgICAgICAgICAgbGFiZWw6IHsKICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9OwogICAgICAgICAgfQogICAgICAgICAgY29uc3QgZm9ybWF0TmFtZSA9IGl0ZW0uYmxvY2tfaGVhZGVyLm1pbmVyOwogICAgICAgICAgbGV0IHN5bWJvbDsKICAgICAgICAgIGlmIChpdGVtLmNpZCA9PT0gdGhpcy5oYXNoKSB7CiAgICAgICAgICAgIHN5bWJvbCA9IGBpbWFnZTovLyR7dGhpcy5hY3RpdmVTcmN9YDsKICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHsKICAgICAgICAgICAgc3ltYm9sID0gYGltYWdlOi8vJHt0aGlzLnRpY2tldFNyY31gOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgc3ltYm9sID0gYGltYWdlOi8vJHt0aGlzLm5vcm1hbFNyY31gOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgbmFtZTogaXRlbS5jaWQsCiAgICAgICAgICAgIG9yaWdpbkRhdGE6IGl0ZW0sCiAgICAgICAgICAgIHZhbHVlOiBpdGVtLmNvb3JkLAogICAgICAgICAgICBzeW1ib2w6IHN5bWJvbCwKICAgICAgICAgICAgc3ltYm9sU2l6ZTogWzU2ICogcmF0ZSwgMTcgKiByYXRlXSwKICAgICAgICAgICAgc3ltYm9sT2Zmc2V0OiBbMTAgKiByYXRlLCAwXSwKICAgICAgICAgICAgaXNUaWNrZXQ6IGluZGV4ID09PSAwLAogICAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICAgIGNvbG9yOgogICAgICAgICAgICAgICAgaW5kZXggPT09IDAgfHwgaXRlbS5jaWQgPT09IHRoaXMuaGFzaCA/IHRpY2tldE5vZGUgOiBvdGhlck5vZGUsCiAgICAgICAgICAgICAgZm9ybWF0dGVyKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE5hbWU7CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBmb250U2l6ZTogMTIgKiByYXRlCiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHByZS5jb25jYXQoY29vcmRzKTsKICAgICAgfSwgW10pOyAvL2dlbmVyYXRlIGVjaGFydHMgbm9kZXMKICAgICAgY29uc3QgbGlua0xpc3QgPSBub2RlTGlzdAogICAgICAgIC5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7CiAgICAgICAgICBpZiAoIWl0ZW0uaXNUaWNrZXQpIHsKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gaW5kZXg7CiAgICAgICAgfSkKICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gewogICAgICAgICAgcmV0dXJuIGl0ZW0gIT09IG51bGw7CiAgICAgICAgfSkKICAgICAgICAubWFwKChpdGVtLCBpbmRleCwgYXJyKSA9PiB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBzb3VyY2U6IGl0ZW0sCiAgICAgICAgICAgIHRhcmdldDogYXJyW2luZGV4ICsgMV0sCiAgICAgICAgICAgIGluZGV4OiBpbmRleCwKICAgICAgICAgICAgaGVpZ2h0OiBub2RlTGlzdFtpdGVtXS5vcmlnaW5EYXRhLmJsb2NrX2hlYWRlci5oZWlnaHQsCiAgICAgICAgICAgIGlzTnVsbDogbm9kZUxpc3RbaXRlbV0uaXNOdWxsLAogICAgICAgICAgICBibG9ja0NvdW50OiBub2RlTGlzdFtpdGVtXS5vcmlnaW5EYXRhLmJsb2NrQ291bnQsCiAgICAgICAgICAgIHg6IG5vZGVMaXN0W2l0ZW1dLm9yaWdpbkRhdGEuY29vcmRbMF0sCiAgICAgICAgICAgIGxhYmVsOiB7CiAgICAgICAgICAgICAgbm9ybWFsOiB7CiAgICAgICAgICAgICAgICBzaG93OiBmYWxzZQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSwKICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgbm9ybWFsOiB7CiAgICAgICAgICAgICAgICBjb2xvcjogbGluawogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICB9KTsgLy9saW5lcwogICAgICBjb25zdCBzdGFydEhlaWdodCA9IHRoaXMuc3RhcnRIZWlnaHQ7CgogICAgICAvL0NoYW5nZSB0aGUgaGVpZ2h0IG9mIGEgZ3JhcGggYWNjb3JkaW5nIHRvIHRoZSBudW1iZXIgb2YgYmxvY2tzCiAgICAgIGNvbnN0IG1heENvdW50ID0gbGlua0xpc3QKICAgICAgICAubWFwKGl0ZW0gPT4gewogICAgICAgICAgcmV0dXJuIGl0ZW0uYmxvY2tDb3VudDsKICAgICAgICB9KQogICAgICAgIC5zb3J0KChhLCBiKSA9PiBhIC0gYikKICAgICAgICAucmV2ZXJzZSgpWzBdOwogICAgICB0aGlzLnR5cGVTdHlsZSA9IHsKICAgICAgICBtYXJnaW5Ub3A6IGAke21heENvdW50ICogMjAgLSAyMDB9cHhgCiAgICAgIH07CiAgICAgIGxldCBsaW5lTGlzdCA9IFtdOwogICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmZvcm1hdE51bWJlcjsKICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNTsgaSsrKSB7CiAgICAgICAgbGluZUxpc3QucHVzaCh7CiAgICAgICAgICB4QXhpczogaSwKICAgICAgICAgIGxhYmVsOiB7CiAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgIGZvcm1hdHRlcigpIHsKICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0KHN0YXJ0SGVpZ2h0IC0gaSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfQogICAgICBsZXQgYXJlYURhdGEgPSBbXTsKICAgICAgbGlua0xpc3QuZm9yRWFjaChpdGVtID0+IHsKICAgICAgICBsZXQgYm9yZGVyQ29sb3IgPSBtYXJrQXJlYUJvcmRlciwKICAgICAgICAgIGJvcmRlcldpZHRoID0gMTsKICAgICAgICBpZiAoaGVpZ2h0ICYmIHN0YXJ0SGVpZ2h0IC0gaGVpZ2h0ID09IGl0ZW0ueCkgewogICAgICAgICAgYm9yZGVyQ29sb3IgPSBtYXJrQXJlYUFjdGl2ZUJvcmRlcjsKICAgICAgICAgIGJvcmRlcldpZHRoID0gMjsKICAgICAgICB9CiAgICAgICAgYXJlYURhdGEucHVzaChbCiAgICAgICAgICB7CiAgICAgICAgICAgIGNvb3JkOiBbaXRlbS54IC0gMC4yLCAoaXRlbS5ibG9ja0NvdW50ICsgMSkgKiA1XSwKICAgICAgICAgICAgaXRlbVN0eWxlOiB7CiAgICAgICAgICAgICAgYm9yZGVyQ29sb3IsCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGgKICAgICAgICAgICAgfQogICAgICAgICAgfSwKICAgICAgICAgIHsgY29vcmQ6IFtpdGVtLnggKyAwLjM3NiwgMV0gfQogICAgICAgIF0pOwogICAgICB9KTsKICAgICAgdmFyIG9wdGlvbiA9IHsKICAgICAgICB4QXhpczogewogICAgICAgICAgc2hvdzogZmFsc2UsCiAgICAgICAgICBib3VuZGFyeUdhcDogZmFsc2UsCiAgICAgICAgICBtaW46IC0xLAogICAgICAgICAgbWF4OiAxNSwKICAgICAgICAgIGF4aXNMaW5lOiB7CiAgICAgICAgICAgIHNob3c6IGZhbHNlCiAgICAgICAgICB9LAogICAgICAgICAgYXhpc1RpY2s6IHsKICAgICAgICAgICAgc2hvdzogdHJ1ZSwKICAgICAgICAgICAgYWxpZ25XaXRoTGFiZWw6IHRydWUKICAgICAgICAgIH0sCiAgICAgICAgICBzcGxpdExpbmU6IHsKICAgICAgICAgICAgc2hvdzogZmFsc2UKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHlBeGlzOiB7CiAgICAgICAgICBtaW46IDAsCiAgICAgICAgICBtYXg6IDcwLAogICAgICAgICAgc2hvdzogZmFsc2UsCiAgICAgICAgICB0eXBlOiAidmFsdWUiLAogICAgICAgICAgaW52ZXJzZTogdHJ1ZQogICAgICAgIH0sCiAgICAgICAgZ3JpZDogewogICAgICAgICAgdG9wOiA0MCAqIHJhdGUsCiAgICAgICAgICBsZWZ0OiAtNDAsCiAgICAgICAgICByaWdodDogMCwKICAgICAgICAgIGJvdHRvbTogMAogICAgICAgIH0sCiAgICAgICAgc2VyaWVzOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgIHR5cGU6ICJncmFwaCIsCiAgICAgICAgICAgIGxheW91dDogIm5vbmUiLAogICAgICAgICAgICBpZDogImEiLAogICAgICAgICAgICBjb29yZGluYXRlU3lzdGVtOiAiY2FydGVzaWFuMmQiLAogICAgICAgICAgICBlZGdlU3ltYm9sOiBbIiIsICJhcnJvdyJdLAogICAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgICAgcG9zaXRpb246ICJpbnNpZGUiCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgIG5vcm1hbDogewogICAgICAgICAgICAgICAgd2lkdGg6IDIsCiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogIm5vbmUiCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBtYXJrTGluZTogewogICAgICAgICAgICAgIHN5bWJvbDogWyJub25lIiwgIm5vbmUiXSwKICAgICAgICAgICAgICBzaWxlbnQ6IGZhbHNlLAogICAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgICAgY29sb3I6IHNlcmllc01hcmtMaW5lLAogICAgICAgICAgICAgICAgd2lkdGg6IDEsCiAgICAgICAgICAgICAgICB0eXBlOiAic29saWQiCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBkYXRhOiBsaW5lTGlzdCwKICAgICAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICAgICAgcG9zaXRpb246ICJzdGFydCIsCiAgICAgICAgICAgICAgICBjb2xvcjogc2VyaWVzTWFya0xpbmVMYWJlbCwKICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMiAqIHJhdGUKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1hcmtBcmVhOiB7CiAgICAgICAgICAgICAgZGF0YTogYXJlYURhdGEsCiAgICAgICAgICAgICAgaXRlbVN0eWxlOiB7CiAgICAgICAgICAgICAgICBjb2xvcjogbWFya0FyZWEsCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogbWFya0FyZWFCb3JkZXIsCiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMSwKICAgICAgICAgICAgICAgIGJvcmRlclR5cGU6ICJkb3R0ZWQiCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICBkYXRhOiBub2RlTGlzdCwKICAgICAgICAgICAgbGlua3M6IGxpbmtMaXN0LAogICAgICAgICAgICB6OiAwLAogICAgICAgICAgICB6bGV2ZWw6IDQKICAgICAgICAgIH0KICAgICAgICBdCiAgICAgIH07CiAgICAgIGNoYXJ0LnNldE9wdGlvbihvcHRpb24pOwogICAgfSwKICAgIGFzeW5jIGdvUmlnaHQoKSB7CiAgICAgIGxldCBqdW1wSGVpZ2h0ID0gTWF0aC5tYXgodGhpcy5zdGFydEhlaWdodCAtIDE1LCAxNSk7CiAgICAgIGF3YWl0IHRoaXMuZ2V0VGlwc2V0KGp1bXBIZWlnaHQpOwogICAgICB0aGlzLmdvVG8oInRpcHNldCIsIHsKICAgICAgICBxdWVyeTogewogICAgICAgICAganVtcEhlaWdodAogICAgICAgIH0KICAgICAgfSk7CiAgICB9LAogICAgYXN5bmMgZ29MZWZ0KCkgewogICAgICBsZXQganVtcEhlaWdodCA9IDA7CiAgICAgIGlmICh0aGlzLnN0YXJ0SGVpZ2h0ID09PSB0aGlzLmp1bXBTYWZlSGVpZ2h0KSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGlmICh0aGlzLmp1bXBTYWZlSGVpZ2h0ID09PSAwKSB7CiAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCBnZXRMYXRlc3RCbG9jaygxKTsKICAgICAgICB0aGlzLmp1bXBTYWZlSGVpZ2h0ID0gTnVtYmVyKGRhdGEuYmxvY2tfaGVhZGVyWzBdLmJsb2NrX2hlYWRlci5oZWlnaHQpOwogICAgICB9CiAgICAgIGlmIChOdW1iZXIodGhpcy5zdGFydEhlaWdodCkgKyAxNSA+PSB0aGlzLmp1bXBTYWZlSGVpZ2h0KSB7CiAgICAgICAganVtcEhlaWdodCA9IHRoaXMuanVtcFNhZmVIZWlnaHQ7CiAgICAgIH0gZWxzZSB7CiAgICAgICAganVtcEhlaWdodCA9IE51bWJlcih0aGlzLnN0YXJ0SGVpZ2h0KSArIDE1OwogICAgICB9CiAgICAgIGF3YWl0IHRoaXMuZ2V0VGlwc2V0KGp1bXBIZWlnaHQpOwogICAgICB0aGlzLmdvVG8oInRpcHNldCIsIHsKICAgICAgICBxdWVyeTogewogICAgICAgICAganVtcEhlaWdodDoganVtcEhlaWdodAogICAgICAgIH0KICAgICAgfSk7CiAgICB9CiAgfQp9Owo="},{"version":3,"sources":["TicketChain.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"TicketChain.vue","sourceRoot":"src/views/tipset/components","sourcesContent":["<template>\n  <div class=\"ticket-chain\">\n    <div class=\"chart-con\">\n      <div\n        class=\"chart\"\n        ref=\"chart\"\n        v-loading=\"loading\"\n        element-loading-background=\"var(--board-bg-color)\"\n      ></div>\n      <div class=\"block-type\" :style=\"typeStyle\">\n        <div class=\"arrow left\" @click=\"goLeft\" v-if=\"!atIndex\">\n          <span class=\"el-icon-arrow-left\"></span>\n        </div>\n        <div class=\"type-list\">\n          <span>\n            <i class=\"null\"></i>\n            {{ $t(\"tipset.blockType\")[0] }}\n          </span>\n          <span>\n            <i class=\"ticket\"></i>\n            {{ $t(\"tipset.blockType\")[1] }}\n          </span>\n          <span>\n            <i class=\"normal\"></i>\n            {{ $t(\"tipset.blockType\")[2] }}\n          </span>\n        </div>\n        <div @click=\"goRight\" class=\"arrow right\" v-if=\"!atIndex\">\n          <!-- <img src=\"@/assets/image/icons/right.png\" alt /> -->\n          <span class=\"el-icon-arrow-right\"></span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nimport { getBlockByCid, getTipset } from \"@/api/tipset\";\nimport { getLatestBlock } from \"@/api/home\";\nimport { getBlockCoord } from \"../tool\";\nimport { mapState } from \"vuex\";\nimport Null from \"@/assets/image/block/null.png\";\nimport Ticket from \"@/assets/image/block/ticket.png\";\nimport Normal from \"@/assets/image/block/normal.png\";\nimport Active from \"@/assets/image/block/active.png\";\nimport NormalDark from \"@/assets/image/block/normal-dark.png\";\nimport NullDark from \"@/assets/image/block/null-dark.png\";\nlet chart;\nexport default {\n  name: \"TipsetChain\",\n  data() {\n    return {\n      tipsets: [],\n      startHeight: 0,\n      hashList: [],\n      loading: false,\n      typeStyle: {\n        marginTop: \"-160px\"\n      },\n      jumpSafeHeight: 0\n    };\n  },\n  props: {\n    hash: {\n      type: String,\n      default: \"\"\n    },\n    height: {\n      type: Number,\n      default: 0\n    }\n  },\n  computed: {\n    ...mapState([\"defaultHeight\"]),\n    normalSrc() {\n      return this.theme === \"light\" ? Normal : NormalDark;\n    },\n    ticketSrc() {\n      return this.theme === \"light\" ? Ticket : Active;\n    },\n    activeSrc() {\n      return this.theme === \"light\" ? Active : Ticket;\n    },\n    nullSrc() {\n      return this.theme === \"light\" ? Null : NullDark;\n    }\n  },\n  watch: {\n    height(v) {\n      if ((v <= this.startHeight && v > this.startHeight - 15) || v == 0) {\n        this.drawChart();\n      } else {\n        this.getTipset(v);\n      }\n    },\n    async hash(v) {\n      if (!v) {\n        return;\n      }\n      if (this.hashList.includes(v)) {\n        this.drawChart();\n      } else {\n        //for parent hash click\n        let data = await getBlockByCid({\n          cid: this.$route.query.hash\n        });\n        const height = data.blocks[0].block_header.height;\n        this.getTipset(height);\n      }\n    },\n    defaultHeight: {\n      handler(h) {\n        const { height, hash, jumpHeight } = this.$route.query;\n        if ((height || hash || jumpHeight) && !this.atIndex) {\n          return;\n        }\n        if (h != 0) {\n          this.startHeight = h;\n          this.getTipset(h);\n        }\n      }\n    },\n    theme() {\n      this.drawChart();\n    }\n  },\n  async mounted() {\n    chart = this.$chart.init(this.$refs.chart);\n    const height = this.height;\n    let currentHeight;\n    if (height) {\n      currentHeight = height;\n    } else if (this.hash) {\n      let data = await getBlockByCid({\n        cid: this.$route.query.hash\n      });\n      const height = data.blocks[0].block_header.height;\n      currentHeight = height;\n    } else {\n      let data = await getLatestBlock(1);\n      const height = data.block_header[0].block_header.height;\n      currentHeight = height;\n      this.jumpSafeHeight = height;\n    }\n    this.getTipset(currentHeight);\n    chart.on(\"click\", e => {\n      if (e.data.originData) {\n        this.$emit(\"hash-change\", e.data.originData.cid);\n      }\n      if (e.componentType === \"markLine\") {\n        this.$emit(\"height-change\", String(this.startHeight - e.value));\n      }\n    });\n  },\n  methods: {\n    async getTipset(height) {\n      if (height == 0) {\n        return;\n      }\n      if (height < 15) {\n        height = 15;\n      }\n      try {\n        this.loading = true;\n        const res = await getTipset({\n          end_height: height,\n          count: 15\n        });\n        this.loading = false;\n        let blocks = [];\n        const reverse = res.tipsets.reverse();\n        reverse.forEach(item => {\n          if (item.tipset.length > 0) {\n            blocks = blocks.concat(item.tipset);\n          }\n        });\n        blocks = blocks.map(item => {\n          const { size, cid, reward, block_header, msg_cids } = item;\n          const {\n            timestamp,\n            height,\n            miner,\n            parent_weight,\n            tickets,\n            parents,\n            parent_state_root\n          } = block_header;\n\n          return {\n            height: this.formatNumber(height),\n            hash: cid,\n            timestamp: this.formatTime(timestamp),\n            utcTime: this.getFormatTime(timestamp),\n            size: this.formatNumber(size),\n            mesLength: msg_cids.length,\n            miner,\n            reward,\n            parents,\n            parent_weight: this.formatNumber(parent_weight),\n            tickets,\n            state_root: parent_state_root\n          };\n        });\n        const hashList = blocks.map(item => {\n          return item.hash;\n        });\n        this.hashList = hashList;\n        this.startHeight = height;\n        this.tipsets = Object.freeze(reverse);\n        this.$emit(\"get-blocks\", blocks);\n        this.drawChart();\n      } catch (e) {\n        this.loading = false;\n      }\n    },\n    drawChart() {\n      const height = this.height;\n      const rate = this.rate;\n      const {\n        ticketNode,\n        otherNode,\n        link,\n        seriesMarkLine,\n        seriesMarkLineLabel,\n        markArea,\n        markAreaBorder,\n        markAreaActiveBorder\n      } = this.chartTheme.tipset;\n      this.tipsets.forEach((item, index) => {\n        item.tipset = getBlockCoord(item.tipset, index, item.min_ticket_block);\n      }); //get coords\n      const nodeList = this.tipsets.reduce((pre, cur) => {\n        const coords = cur.tipset.map((item, index) => {\n          if (!item.cid) {\n            return {\n              value: item.coord,\n              symbol: `image://${this.nullSrc}`,\n              symbolSize: [56 * rate, 17 * rate],\n              isTicket: false,\n              label: {\n                show: false\n              }\n            };\n          }\n          const formatName = item.block_header.miner;\n          let symbol;\n          if (item.cid === this.hash) {\n            symbol = `image://${this.activeSrc}`;\n          } else if (index === 0) {\n            symbol = `image://${this.ticketSrc}`;\n          } else {\n            symbol = `image://${this.normalSrc}`;\n          }\n          return {\n            name: item.cid,\n            originData: item,\n            value: item.coord,\n            symbol: symbol,\n            symbolSize: [56 * rate, 17 * rate],\n            symbolOffset: [10 * rate, 0],\n            isTicket: index === 0,\n            label: {\n              color:\n                index === 0 || item.cid === this.hash ? ticketNode : otherNode,\n              formatter() {\n                return formatName;\n              },\n              fontSize: 12 * rate\n            }\n          };\n        });\n        return pre.concat(coords);\n      }, []); //generate echarts nodes\n      const linkList = nodeList\n        .map((item, index) => {\n          if (!item.isTicket) {\n            return null;\n          }\n          return index;\n        })\n        .filter(item => {\n          return item !== null;\n        })\n        .map((item, index, arr) => {\n          return {\n            source: item,\n            target: arr[index + 1],\n            index: index,\n            height: nodeList[item].originData.block_header.height,\n            isNull: nodeList[item].isNull,\n            blockCount: nodeList[item].originData.blockCount,\n            x: nodeList[item].originData.coord[0],\n            label: {\n              normal: {\n                show: false\n              }\n            },\n            lineStyle: {\n              normal: {\n                color: link\n              }\n            }\n          };\n        }); //lines\n      const startHeight = this.startHeight;\n\n      //Change the height of a graph according to the number of blocks\n      const maxCount = linkList\n        .map(item => {\n          return item.blockCount;\n        })\n        .sort((a, b) => a - b)\n        .reverse()[0];\n      this.typeStyle = {\n        marginTop: `${maxCount * 20 - 200}px`\n      };\n      let lineList = [];\n      const format = this.formatNumber;\n      for (let i = 0; i < 15; i++) {\n        lineList.push({\n          xAxis: i,\n          label: {\n            show: true,\n            formatter() {\n              return format(startHeight - i);\n            }\n          }\n        });\n      }\n      let areaData = [];\n      linkList.forEach(item => {\n        let borderColor = markAreaBorder,\n          borderWidth = 1;\n        if (height && startHeight - height == item.x) {\n          borderColor = markAreaActiveBorder;\n          borderWidth = 2;\n        }\n        areaData.push([\n          {\n            coord: [item.x - 0.2, (item.blockCount + 1) * 5],\n            itemStyle: {\n              borderColor,\n              borderWidth\n            }\n          },\n          { coord: [item.x + 0.376, 1] }\n        ]);\n      });\n      var option = {\n        xAxis: {\n          show: false,\n          boundaryGap: false,\n          min: -1,\n          max: 15,\n          axisLine: {\n            show: false\n          },\n          axisTick: {\n            show: true,\n            alignWithLabel: true\n          },\n          splitLine: {\n            show: false\n          }\n        },\n        yAxis: {\n          min: 0,\n          max: 70,\n          show: false,\n          type: \"value\",\n          inverse: true\n        },\n        grid: {\n          top: 40 * rate,\n          left: -40,\n          right: 0,\n          bottom: 0\n        },\n        series: [\n          {\n            type: \"graph\",\n            layout: \"none\",\n            id: \"a\",\n            coordinateSystem: \"cartesian2d\",\n            edgeSymbol: [\"\", \"arrow\"],\n            label: {\n              show: true,\n              position: \"inside\"\n            },\n            lineStyle: {\n              normal: {\n                width: 2,\n                shadowColor: \"none\"\n              }\n            },\n            markLine: {\n              symbol: [\"none\", \"none\"],\n              silent: false,\n              lineStyle: {\n                color: seriesMarkLine,\n                width: 1,\n                type: \"solid\"\n              },\n              data: lineList,\n              label: {\n                position: \"start\",\n                color: seriesMarkLineLabel,\n                fontSize: 12 * rate\n              }\n            },\n            markArea: {\n              data: areaData,\n              itemStyle: {\n                color: markArea,\n                borderColor: markAreaBorder,\n                borderWidth: 1,\n                borderType: \"dotted\"\n              }\n            },\n            data: nodeList,\n            links: linkList,\n            z: 0,\n            zlevel: 4\n          }\n        ]\n      };\n      chart.setOption(option);\n    },\n    async goRight() {\n      let jumpHeight = Math.max(this.startHeight - 15, 15);\n      await this.getTipset(jumpHeight);\n      this.goTo(\"tipset\", {\n        query: {\n          jumpHeight\n        }\n      });\n    },\n    async goLeft() {\n      let jumpHeight = 0;\n      if (this.startHeight === this.jumpSafeHeight) {\n        return;\n      }\n      if (this.jumpSafeHeight === 0) {\n        let data = await getLatestBlock(1);\n        this.jumpSafeHeight = Number(data.block_header[0].block_header.height);\n      }\n      if (Number(this.startHeight) + 15 >= this.jumpSafeHeight) {\n        jumpHeight = this.jumpSafeHeight;\n      } else {\n        jumpHeight = Number(this.startHeight) + 15;\n      }\n      await this.getTipset(jumpHeight);\n      this.goTo(\"tipset\", {\n        query: {\n          jumpHeight: jumpHeight\n        }\n      });\n    }\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n.ticket-chain {\n  border-radius: 8px;\n  box-shadow: 0px 1px 7px 9px rgba(0, 0, 0, 0.03);\n  background: var(--board-bg-color);\n  .chart-con {\n    width: 100%;\n    .chart {\n      width: 100%;\n      height: 350px;\n    }\n  }\n  .block-type {\n    position: relative;\n    z-index: 10;\n    .arrow {\n      position: absolute;\n      top: -10px;\n      font-size: 30px;\n      color: var(--main-text-color);\n      cursor: pointer;\n      &.left {\n        left: 20px;\n      }\n      &.right {\n        right: 20px;\n      }\n    }\n  }\n  .block-type div.type-list {\n    width: 500px;\n    margin: 0 auto;\n    padding-bottom: 20px;\n    color: var(--main-text-color);\n    span {\n      margin-left: 20px;\n    }\n    i {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      border-radius: 50%;\n      margin-right: 5px;\n      &.null {\n        background: var(--null-block-bg-color);\n      }\n      &.ticket {\n        background: var(--ticket-block-bg-color);\n      }\n      &.normal {\n        border: 1px solid var(--other-block-border-color);\n        width: 8px;\n        height: 8px;\n      }\n    }\n  }\n}\n</style>\n"]}]}