{"remainingRequest":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/wuzhanfly/git/filscan-frontend/src/views/stats/Map.vue?vue&type=style&index=0&id=1c3eb922&lang=scss&scoped=true&","dependencies":[{"path":"/home/wuzhanfly/git/filscan-frontend/src/views/stats/Map.vue","mtime":1612684657988},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/wuzhanfly/git/filscan-frontend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLm5vZGUtbWFwIHsKICBoZWlnaHQ6IGNhbGMoMTAwdmggLSAyMDBweCk7CiAgcG9zaXRpb246IHJlbGF0aXZlOwogIC5jaGFydC1jb24gewogICAgd2lkdGg6IDEwMCU7CiAgICBoZWlnaHQ6IDEwMCU7CiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1ib2FyZC1iZy1jb2xvcik7CiAgfQogIEBtZWRpYSAobWF4LXdpZHRoOiA3NjhweCkgewogICAgLmNoYXJ0LWNvbiB7CiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["Map.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Map.vue","sourceRoot":"src/views/stats","sourcesContent":["<template>\n  <div class=\"node-map bottom-10\">\n    <div\n      ref=\"chart\"\n      class=\"chart-con\"\n      v-loading=\"loading\"\n      element-loading-background=\"var(--board-bg-color)\"\n    ></div>\n  </div>\n</template>\n<script>\nimport { getMapData } from \"@/api/stats\";\nlet chart;\nexport default {\n  name: \"NodeMap\",\n  data() {\n    return {\n      loading: false,\n      points: [],\n      timer: null\n    };\n  },\n  methods: {\n    drawNodeMap(zoom) {\n      const data = this.points;\n      const { bg, scatter, geo, tooltip } = this.chartTheme.map;\n      const { item, border, emphasis } = geo;\n      let symbolSize = 4;\n      if (zoom > 50) {\n        symbolSize = 10;\n      }\n      const vm = this;\n      var series = [];\n      series.push({\n        type: \"scatter\",\n        coordinateSystem: \"geo\",\n        zlevel: 2,\n        label: {\n          normal: {\n            show: false\n          },\n          emphasis: {\n            show: false\n          }\n        },\n        blendMode: \"lighter\",\n        symbol: \"circle\",\n        symbolSize: symbolSize,\n        itemStyle: {\n          normal: {\n            show: false,\n            color: scatter\n          }\n        },\n        data: data,\n        large: true\n      });\n      series[0].data = series[0].data.slice(0, 3000);\n      chart.setOption({\n        backgroundColor: bg,\n        tooltip: {\n          trigger: \"item\",\n          backgroundColor: tooltip,\n          showDelay: 0,\n          hideDelay: 300,\n          enterable: true,\n          formatter: function(params) {\n            const { name, pid, ip } = params.data;\n            return vm.$t(\"chart.map\", { name, pid, ip });\n          }\n        },\n        geo: {\n          map: \"world\",\n          label: {\n            emphasis: {\n              show: false\n            }\n          },\n          roam: true,\n          layoutCenter: [\"50%\", \"50%\"],\n          layoutSize: \"180%\",\n          scaleLimit: {\n            min: 1,\n            max: 150\n          },\n          itemStyle: {\n            normal: {\n              color: item,\n              borderColor: border\n            },\n            emphasis: {\n              color: emphasis\n            }\n          },\n          animation: false\n        },\n        animation: false,\n        series: series\n      });\n    },\n    getRandom() {\n      const pi = Math.PI;\n      let theta = Math.random() * 2 * pi;\n      let radius = 20 * Math.random();\n      const x = radius * Math.sin(theta);\n      const y = radius * Math.cos(theta);\n      return {\n        x: x / 100,\n        y: y / 100\n      };\n    },\n    async getMapData() {\n      try {\n        this.loading = true;\n        let res = await getMapData();\n        const points = [];\n        this.loading = false;\n        res.peer_point.forEach(item => {\n          const len = item.peers.length;\n          item.peers.forEach(peer => {\n            const { x, y } = this.getRandom();\n            const value =\n              len === 1\n                ? [item.longitude, item.latitude, 10]\n                : [item.longitude + x, item.latitude + y, 10];\n            points.push({\n              name: item.location_en,\n              value,\n              pid: peer.peer_id,\n              ip: peer.ip\n            });\n          });\n        });\n        this.points = Object.freeze(points);\n        this.drawNodeMap();\n      } catch (e) {\n        this.loading = false;\n      }\n    }\n  },\n  mounted() {\n    chart = this.$chart.init(this.$refs.chart);\n    chart.on(\"georoam\", () => {\n      clearTimeout(this.timer);\n      const zoom = chart.getOption().geo[0].zoom;\n      this.timer = setTimeout(() => {\n        this.drawNodeMap(zoom);\n      }, 100);\n    });\n    this.getMapData();\n  },\n  watch: {\n    theme() {\n      this.drawNodeMap();\n    }\n  }\n};\n</script>\n<style lang=\"scss\" scoped>\n.node-map {\n  height: calc(100vh - 200px);\n  position: relative;\n  .chart-con {\n    width: 100%;\n    height: 100%;\n    background: var(--board-bg-color);\n  }\n  @media (max-width: 768px) {\n    .chart-con {\n    }\n  }\n}\n</style>\n"]}]}